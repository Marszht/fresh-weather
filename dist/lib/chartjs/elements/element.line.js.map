{"version":3,"sources":["lib/chartjs/elements/element.line.js"],"names":["module","exports","Chart","helpers","globalDefaults","defaults","global","elements","line","tension","backgroundColor","defaultColor","borderWidth","borderColor","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","capBezierPoints","fill","Line","Element","extend","draw","me","vm","_view","spanGaps","fillPoint","scaleZero","loop","_loop","scaleTop","scaleBottom","ctx","_chart","save","lineToPoint","previousPoint","point","pointVM","steppedLine","lineTo","x","y","bezierCurveTo","controlPointNextX","controlPointNextY","controlPointPreviousX","controlPointPreviousY","points","_children","slice","lastDrawnIndex","length","push","index","current","previous","currentVM","beginPath","previousItem","moveTo","skip","setFillStyle","closePath","globalOptionLineElements","setLineCap","setLineDash","lineDashOffset","setLineJoin","setLineWidth","setStrokeStyle","stroke","restore"],"mappings":"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","file":"element.line.js","sourcesContent":["'use strict';\nmodule.exports = function(Chart) {\n\tvar helpers = Chart.helpers;\n\tvar globalDefaults = Chart.defaults.global;\n\tChart.defaults.global.elements.line = {\n\t\ttension: 0.4,\n\t\tbackgroundColor: globalDefaults.defaultColor,\n\t\tborderWidth: 3,\n\t\tborderColor: globalDefaults.defaultColor,\n\t\tborderCapStyle: 'butt',\n\t\tborderDash: [],\n\t\tborderDashOffset: 0.0,\n\t\tborderJoinStyle: 'miter',\n\t\tcapBezierPoints: true,\n\t\tfill: true, // do we fill in the area between the line and its base axis\n\t};\n\tChart.elements.Line = Chart.Element.extend({\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar vm = me._view;\n\t\t\tvar spanGaps = vm.spanGaps;\n\t\t\tvar fillPoint = vm.scaleZero;\n\t\t\tvar loop = me._loop;\n\t\t\t// Handle different fill modes for cartesian lines\n\t\t\tif (!loop) {\n\t\t\t\tif (vm.fill === 'top') {\n\t\t\t\t\tfillPoint = vm.scaleTop;\n\t\t\t\t} else if (vm.fill === 'bottom') {\n\t\t\t\t\tfillPoint = vm.scaleBottom;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar ctx = me._chart.ctx;\n\t\t\tctx.save();\n\t\t\t// Helper function to draw a line to a point\n\t\t\tfunction lineToPoint(previousPoint, point) {\n\t\t\t\tvar pointVM = point._view;\n\t\t\t\tif (point._view.steppedLine === true) {\n\t\t\t\t\tctx.lineTo(pointVM.x, previousPoint._view.y);\n\t\t\t\t\tctx.lineTo(pointVM.x, pointVM.y);\n\t\t\t\t} else if (point._view.tension === 0) {\n\t\t\t\t\tctx.lineTo(pointVM.x, pointVM.y);\n\t\t\t\t} else {\n\t\t\t\t\tctx.bezierCurveTo(\n\t\t\t\t\t\tpreviousPoint._view.controlPointNextX,\n\t\t\t\t\t\tpreviousPoint._view.controlPointNextY,\n\t\t\t\t\t\tpointVM.controlPointPreviousX,\n\t\t\t\t\t\tpointVM.controlPointPreviousY,\n\t\t\t\t\t\tpointVM.x,\n\t\t\t\t\t\tpointVM.y\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar points = me._children.slice(); // clone array\n\t\t\tvar lastDrawnIndex = -1;\n\t\t\t// If we are looping, adding the first point again\n\t\t\tif (loop && points.length) {\n\t\t\t\tpoints.push(points[0]);\n\t\t\t}\n\t\t\tvar index, current, previous, currentVM;\n\t\t\t// Fill Line\n\t\t\tif (points.length && vm.fill) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\t\t\tcurrent = points[index];\n\t\t\t\t\tprevious = helpers.previousItem(points, index);\n\t\t\t\t\tcurrentVM = current._view;\n\t\t\t\t\t// First point moves to it's starting position no matter what\n\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\tif (loop) {\n\t\t\t\t\t\t\tctx.moveTo(fillPoint.x, fillPoint.y);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.moveTo(currentVM.x, fillPoint);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t\t\tctx.lineTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\t\t\t\t\t\tif (currentVM.skip) {\n\t\t\t\t\t\t\t// Only do this if this is the first point that is skipped\n\t\t\t\t\t\t\tif (!spanGaps && lastDrawnIndex === (index - 1)) {\n\t\t\t\t\t\t\t\tif (loop) {\n\t\t\t\t\t\t\t\t\tctx.lineTo(fillPoint.x, fillPoint.y);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tctx.lineTo(previous._view.x, fillPoint);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (lastDrawnIndex !== (index - 1)) {\n\t\t\t\t\t\t\t\t// There was a gap and this is the first point after the gap. If we've never drawn a point, this is a special case.\n\t\t\t\t\t\t\t\t// If the first data point is NaN, then there is no real gap to skip\n\t\t\t\t\t\t\t\tif (spanGaps && lastDrawnIndex !== -1) {\n\t\t\t\t\t\t\t\t\t// We are spanning the gap, so simple draw a line to this point\n\t\t\t\t\t\t\t\t\tlineToPoint(previous, current);\n\t\t\t\t\t\t\t\t} else if (loop) {\n\t\t\t\t\t\t\t\t\tctx.lineTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tctx.lineTo(currentVM.x, fillPoint);\n\t\t\t\t\t\t\t\t\tctx.lineTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\t\t\tlineToPoint(previous, current);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!loop && lastDrawnIndex !== -1) {\n\t\t\t\t\tctx.lineTo(points[lastDrawnIndex]._view.x, fillPoint);\n\t\t\t\t}\n\t\t\t\tctx.setFillStyle(vm.backgroundColor || globalDefaults.defaultColor);\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.fill();\n\t\t\t}\n\t\t\t// Stroke Line Options\n\t\t\tvar globalOptionLineElements = globalDefaults.elements.line;\n\t\t\tctx.setLineCap(vm.borderCapStyle || globalOptionLineElements.borderCapStyle);\n\t\t\t// IE 9 and 10 do not support line dash\n\t\t\tif (ctx.setLineDash) {\n\t\t\t\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n\t\t\t}\n\t\t\tctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\n\t\t\tctx.setLineJoin(vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle);\n\t\t\tctx.setLineWidth(vm.borderWidth || globalOptionLineElements.borderWidth);\n\t\t\tctx.setStrokeStyle(vm.borderColor || globalDefaults.defaultColor);\n\t\t\t// Stroke Line\n\t\t\tctx.beginPath();\n\t\t\tlastDrawnIndex = -1;\n\t\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\t\tcurrent = points[index];\n\t\t\t\tprevious = helpers.previousItem(points, index);\n\t\t\t\tcurrentVM = current._view;\n\t\t\t\t// First point moves to it's starting position no matter what\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\tif ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\n\t\t\t\t\t\t\t// There was a gap and this is the first point after the gap\n\t\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\t\tlineToPoint(previous, current);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx.stroke();\n\t\t\tctx.restore();\n\t\t}\n\t});\n};\n"]}