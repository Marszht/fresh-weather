{"version":3,"sources":["lib/chartjs/scales/scale.category.js"],"names":["module","exports","Chart","helpers","defaultConfig","position","DatasetScale","Scale","extend","getLabels","data","chart","isHorizontal","xLabels","yLabels","labels","determineDataLimits","me","minIndex","maxIndex","length","findIndex","options","ticks","min","undefined","indexOf","max","buildTicks","slice","getLabelForIndex","index","datasetIndex","getRightValue","datasets","getPixelForValue","value","includeOffset","offsetAmt","Math","gridLines","offsetGridLines","isNaN","idx","innerWidth","width","paddingLeft","paddingRight","valueWidth","widthOffset","left","round","innerHeight","height","paddingTop","paddingBottom","valueHeight","heightOffset","top","getPixelForTick","getValueForPixel","pixel","horz","innerDimension","valueDimension","getBasePixel","bottom","scaleService","registerScaleType"],"mappings":"AAAA;;AACAA,OAAOC,OAAP,GAAiB,UAASC,KAAT,EAAgB;AAChC,KAAIC,UAAUD,MAAMC,OAApB;AACA;AACA,KAAIC,gBAAgB;AACnBC,YAAU;AADS,EAApB;AAGA,KAAIC,eAAeJ,MAAMK,KAAN,CAAYC,MAAZ,CAAmB;AACrC;;;;;AAKAC,aAAW,qBAAW;AACrB,OAAIC,OAAO,KAAKC,KAAL,CAAWD,IAAtB;AACA,UAAO,CAAC,KAAKE,YAAL,KAAsBF,KAAKG,OAA3B,GAAqCH,KAAKI,OAA3C,KAAuDJ,KAAKK,MAAnE;AACA,GAToC;AAUrC;AACAC,uBAAqB,+BAAW;AAC/B,OAAIC,KAAK,IAAT;AACA,OAAIF,SAASE,GAAGR,SAAH,EAAb;AACAQ,MAAGC,QAAH,GAAc,CAAd;AACAD,MAAGE,QAAH,GAAcJ,OAAOK,MAAP,GAAgB,CAA9B;AACA,OAAIC,SAAJ;AACA,OAAIJ,GAAGK,OAAH,CAAWC,KAAX,CAAiBC,GAAjB,KAAyBC,SAA7B,EAAwC;AACvC;AACAJ,gBAAYlB,QAAQuB,OAAR,CAAgBX,MAAhB,EAAwBE,GAAGK,OAAH,CAAWC,KAAX,CAAiBC,GAAzC,CAAZ;AACAP,OAAGC,QAAH,GAAcG,cAAc,CAAC,CAAf,GAAmBA,SAAnB,GAA+BJ,GAAGC,QAAhD;AACA;AACD,OAAID,GAAGK,OAAH,CAAWC,KAAX,CAAiBI,GAAjB,KAAyBF,SAA7B,EAAwC;AACvC;AACAJ,gBAAYlB,QAAQuB,OAAR,CAAgBX,MAAhB,EAAwBE,GAAGK,OAAH,CAAWC,KAAX,CAAiBI,GAAzC,CAAZ;AACAV,OAAGE,QAAH,GAAcE,cAAc,CAAC,CAAf,GAAmBA,SAAnB,GAA+BJ,GAAGE,QAAhD;AACA;AACDF,MAAGO,GAAH,GAAST,OAAOE,GAAGC,QAAV,CAAT;AACAD,MAAGU,GAAH,GAASZ,OAAOE,GAAGE,QAAV,CAAT;AACA,GA7BoC;AA8BrCS,cAAY,sBAAW;AACtB,OAAIX,KAAK,IAAT;AACA,OAAIF,SAASE,GAAGR,SAAH,EAAb;AACA;AACAQ,MAAGM,KAAH,GAAYN,GAAGC,QAAH,KAAgB,CAAhB,IAAqBD,GAAGE,QAAH,KAAgBJ,OAAOK,MAAP,GAAgB,CAAtD,GAA2DL,MAA3D,GAAoEA,OAAOc,KAAP,CAAaZ,GAAGC,QAAhB,EAA0BD,GAAGE,QAAH,GAAc,CAAxC,CAA/E;AACA,GAnCoC;AAoCrCW,oBAAkB,0BAASC,KAAT,EAAgBC,YAAhB,EAA8B;AAC/C,OAAIf,KAAK,IAAT;AACA,OAAIP,OAAOO,GAAGN,KAAH,CAASD,IAApB;AACA,OAAIE,eAAeK,GAAGL,YAAH,EAAnB;AACA,OAAKF,KAAKG,OAAL,IAAgBD,YAAjB,IAAmCF,KAAKI,OAAL,IAAgB,CAACF,YAAxD,EAAuE;AACtE,WAAOK,GAAGgB,aAAH,CAAiBvB,KAAKwB,QAAL,CAAcF,YAAd,EAA4BtB,IAA5B,CAAiCqB,KAAjC,CAAjB,CAAP;AACA;AACD,UAAOd,GAAGM,KAAH,CAASQ,KAAT,CAAP;AACA,GA5CoC;AA6CrC;AACAI,oBAAkB,0BAASC,KAAT,EAAgBL,KAAhB,EAAuBC,YAAvB,EAAqCK,aAArC,EAAoD;AACrE,OAAIpB,KAAK,IAAT;AACA;AACA,OAAIqB,YAAYC,KAAKZ,GAAL,CAAUV,GAAGE,QAAH,GAAc,CAAd,GAAkBF,GAAGC,QAArB,IAAkCD,GAAGK,OAAH,CAAWkB,SAAX,CAAqBC,eAAtB,GAAyC,CAAzC,GAA6C,CAA9E,CAAV,EAA6F,CAA7F,CAAhB;AACA,OAAIL,UAAUX,SAAV,IAAuBiB,MAAMX,KAAN,CAA3B,EAAyC;AACxC,QAAIhB,SAASE,GAAGR,SAAH,EAAb;AACA,QAAIkC,MAAM5B,OAAOW,OAAP,CAAeU,KAAf,CAAV;AACAL,YAAQY,QAAQ,CAAC,CAAT,GAAaA,GAAb,GAAmBZ,KAA3B;AACA;AACD,OAAId,GAAGL,YAAH,EAAJ,EAAuB;AACtB,QAAIgC,aAAa3B,GAAG4B,KAAH,IAAY5B,GAAG6B,WAAH,GAAiB7B,GAAG8B,YAAhC,CAAjB;AACA,QAAIC,aAAaJ,aAAaN,SAA9B;AACA,QAAIW,cAAeD,cAAcjB,QAAQd,GAAGC,QAAzB,CAAD,GAAuCD,GAAG6B,WAA5D;AACA,QAAI7B,GAAGK,OAAH,CAAWkB,SAAX,CAAqBC,eAArB,IAAwCJ,aAAxC,IAAyDpB,GAAGE,QAAH,KAAgBF,GAAGC,QAAnB,IAA+BmB,aAA5F,EAA2G;AAC1GY,oBAAgBD,aAAa,CAA7B;AACA;AACD,WAAO/B,GAAGiC,IAAH,GAAUX,KAAKY,KAAL,CAAWF,WAAX,CAAjB;AACA;AACD,OAAIG,cAAcnC,GAAGoC,MAAH,IAAapC,GAAGqC,UAAH,GAAgBrC,GAAGsC,aAAhC,CAAlB;AACA,OAAIC,cAAcJ,cAAcd,SAAhC;AACA,OAAImB,eAAgBD,eAAezB,QAAQd,GAAGC,QAA1B,CAAD,GAAwCD,GAAGqC,UAA9D;AACA,OAAIrC,GAAGK,OAAH,CAAWkB,SAAX,CAAqBC,eAArB,IAAwCJ,aAA5C,EAA2D;AAC1DoB,oBAAiBD,cAAc,CAA/B;AACA;AACD,UAAOvC,GAAGyC,GAAH,GAASnB,KAAKY,KAAL,CAAWM,YAAX,CAAhB;AACA,GAvEoC;AAwErCE,mBAAiB,yBAAS5B,KAAT,EAAgBM,aAAhB,EAA+B;AAC/C,UAAO,KAAKF,gBAAL,CAAsB,KAAKZ,KAAL,CAAWQ,KAAX,CAAtB,EAAyCA,QAAQ,KAAKb,QAAtD,EAAgE,IAAhE,EAAsEmB,aAAtE,CAAP;AACA,GA1EoC;AA2ErCuB,oBAAkB,0BAASC,KAAT,EAAgB;AACjC,OAAI5C,KAAK,IAAT;AACA,OAAImB,KAAJ;AACA,OAAIE,YAAYC,KAAKZ,GAAL,CAAUV,GAAGM,KAAH,CAASH,MAAT,IAAoBH,GAAGK,OAAH,CAAWkB,SAAX,CAAqBC,eAAtB,GAAyC,CAAzC,GAA6C,CAAhE,CAAV,EAA+E,CAA/E,CAAhB;AACA,OAAIqB,OAAO7C,GAAGL,YAAH,EAAX;AACA,OAAImD,iBAAiBD,OAAO7C,GAAG4B,KAAH,IAAY5B,GAAG6B,WAAH,GAAiB7B,GAAG8B,YAAhC,CAAP,GAAuD9B,GAAGoC,MAAH,IAAapC,GAAGqC,UAAH,GAAgBrC,GAAGsC,aAAhC,CAA5E;AACA,OAAIS,iBAAiBD,iBAAiBzB,SAAtC;AACAuB,YAASC,OAAO7C,GAAGiC,IAAV,GAAiBjC,GAAGyC,GAA7B;AACA,OAAIzC,GAAGK,OAAH,CAAWkB,SAAX,CAAqBC,eAAzB,EAA0C;AACzCoB,aAAUG,iBAAiB,CAA3B;AACA;AACDH,YAASC,OAAO7C,GAAG6B,WAAV,GAAwB7B,GAAGqC,UAApC;AACA,OAAIO,SAAS,CAAb,EAAgB;AACfzB,YAAQ,CAAR;AACA,IAFD,MAEO;AACNA,YAAQG,KAAKY,KAAL,CAAWU,QAAQG,cAAnB,CAAR;AACA;AACD,UAAO5B,KAAP;AACA,GA7FoC;AA8FrC6B,gBAAc,wBAAW;AACxB,UAAO,KAAKC,MAAZ;AACA;AAhGoC,EAAnB,CAAnB;AAkGAhE,OAAMiE,YAAN,CAAmBC,iBAAnB,CAAqC,UAArC,EAAiD9D,YAAjD,EAA+DF,aAA/D;AACA,CAzGD","file":"scale.category.js","sourcesContent":["'use strict';\nmodule.exports = function(Chart) {\n\tvar helpers = Chart.helpers;\n\t// Default config for a category scale\n\tvar defaultConfig = {\n\t\tposition: 'bottom'\n\t};\n\tvar DatasetScale = Chart.Scale.extend({\n\t\t/**\n\t\t* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n\t\t* else fall back to data.labels\n\t\t* @private\n\t\t*/\n\t\tgetLabels: function() {\n\t\t\tvar data = this.chart.data;\n\t\t\treturn (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n\t\t},\n\t\t// Implement this so that\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\tme.minIndex = 0;\n\t\t\tme.maxIndex = labels.length - 1;\n\t\t\tvar findIndex;\n\t\t\tif (me.options.ticks.min !== undefined) {\n\t\t\t\t// user specified min value\n\t\t\t\tfindIndex = helpers.indexOf(labels, me.options.ticks.min);\n\t\t\t\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n\t\t\t}\n\t\t\tif (me.options.ticks.max !== undefined) {\n\t\t\t\t// user specified max value\n\t\t\t\tfindIndex = helpers.indexOf(labels, me.options.ticks.max);\n\t\t\t\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n\t\t\t}\n\t\t\tme.min = labels[me.minIndex];\n\t\t\tme.max = labels[me.maxIndex];\n\t\t},\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\t// If we are viewing some subset of labels, slice the original array\n\t\t\tme.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tif ((data.xLabels && isHorizontal) || (data.yLabels && !isHorizontal)) {\n\t\t\t\treturn me.getRightValue(data.datasets[datasetIndex].data[index]);\n\t\t\t}\n\t\t\treturn me.ticks[index];\n\t\t},\n\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\tgetPixelForValue: function(value, index, datasetIndex, includeOffset) {\n\t\t\tvar me = this;\n\t\t\t// 1 is added because we need the length but we have the indexes\n\t\t\tvar offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n\t\t\tif (value !== undefined && isNaN(index)) {\n\t\t\t\tvar labels = me.getLabels();\n\t\t\t\tvar idx = labels.indexOf(value);\n\t\t\t\tindex = idx !== -1 ? idx : index;\n\t\t\t}\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar valueWidth = innerWidth / offsetAmt;\n\t\t\t\tvar widthOffset = (valueWidth * (index - me.minIndex)) + me.paddingLeft;\n\t\t\t\tif (me.options.gridLines.offsetGridLines && includeOffset || me.maxIndex === me.minIndex && includeOffset) {\n\t\t\t\t\twidthOffset += (valueWidth / 2);\n\t\t\t\t}\n\t\t\t\treturn me.left + Math.round(widthOffset);\n\t\t\t}\n\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n\t\t\tvar valueHeight = innerHeight / offsetAmt;\n\t\t\tvar heightOffset = (valueHeight * (index - me.minIndex)) + me.paddingTop;\n\t\t\tif (me.options.gridLines.offsetGridLines && includeOffset) {\n\t\t\t\theightOffset += (valueHeight / 2);\n\t\t\t}\n\t\t\treturn me.top + Math.round(heightOffset);\n\t\t},\n\t\tgetPixelForTick: function(index, includeOffset) {\n\t\t\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar value;\n\t\t\tvar offsetAmt = Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n\t\t\tvar horz = me.isHorizontal();\n\t\t\tvar innerDimension = horz ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.paddingBottom);\n\t\t\tvar valueDimension = innerDimension / offsetAmt;\n\t\t\tpixel -= horz ? me.left : me.top;\n\t\t\tif (me.options.gridLines.offsetGridLines) {\n\t\t\t\tpixel -= (valueDimension / 2);\n\t\t\t}\n\t\t\tpixel -= horz ? me.paddingLeft : me.paddingTop;\n\t\t\tif (pixel <= 0) {\n\t\t\t\tvalue = 0;\n\t\t\t} else {\n\t\t\t\tvalue = Math.round(pixel / valueDimension);\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\t\tgetBasePixel: function() {\n\t\t\treturn this.bottom;\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);\n};\n"]}