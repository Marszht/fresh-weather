{"version":3,"sources":["lib/chartjs/core/core.interaction.js"],"names":["module","exports","Chart","helpers","parseVisibleItems","chart","handler","datasets","data","meta","i","j","ilen","jlen","length","isDatasetVisible","getDatasetMeta","element","_view","skip","getIntersectItems","position","elements","inRange","x","y","push","getNearestItems","intersect","distanceMetric","minDistance","Number","POSITIVE_INFINITY","nearestItems","distanceBetweenPoints","center","getCenterPoint","distance","indexMode","e","options","getRelativePosition","pt1","pt2","Math","abs","items","forEach","dataset","datasetIndex","_index","Interaction","modes","single","slice","label","index","_datasetIndex","point","nearest","sort","a","b","sizeA","getArea","sizeB","ret","inXRange","inYRange"],"mappings":"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","file":"core.interaction.js","sourcesContent":["'use strict';\nmodule.exports = function(Chart) {\n\tvar helpers = Chart.helpers;\n\t/**\n\t * Helper function to traverse all of the visible elements in the chart\n\t * @param chart {chart} the chart\n\t * @param handler {Function} the callback to execute for each visible item\n\t */\n\tfunction parseVisibleItems(chart, handler) {\n\t\tvar datasets = chart.data.datasets;\n\t\tvar meta, i, j, ilen, jlen;\n\t\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\n\t\t\tif (!chart.isDatasetVisible(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\tfor (j = 0, jlen = meta.data.length; j < jlen; ++j) {\n\t\t\t\tvar element = meta.data[j];\n\t\t\t\tif (!element._view.skip) {\n\t\t\t\t\thandler(element);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Helper function to get the items that intersect the event position\n\t * @param items {ChartElement[]} elements to filter\n\t * @param position {Point} the point to be nearest to\n\t * @return {ChartElement[]} the nearest items\n\t */\n\tfunction getIntersectItems(chart, position) {\n\t\tvar elements = [];\n\t\tparseVisibleItems(chart, function(element) {\n\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\telements.push(element);\n\t\t\t}\n\t\t});\n\t\treturn elements;\n\t}\n\t/**\n\t * Helper function to get the items nearest to the event position considering all visible items in teh chart\n\t * @param chart {Chart} the chart to look at elements from\n\t * @param position {Point} the point to be nearest to\n\t * @param intersect {Boolean} if true, only consider items that intersect the position\n\t * @param distanceMetric {Function} Optional function to provide the distance between\n\t * @return {ChartElement[]} the nearest items\n\t */\n\tfunction getNearestItems(chart, position, intersect, distanceMetric) {\n\t\tvar minDistance = Number.POSITIVE_INFINITY;\n\t\tvar nearestItems = [];\n\t\tif (!distanceMetric) {\n\t\t\tdistanceMetric = helpers.distanceBetweenPoints;\n\t\t}\n\t\tparseVisibleItems(chart, function(element) {\n\t\t\tif (intersect && !element.inRange(position.x, position.y)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar center = element.getCenterPoint();\n\t\t\tvar distance = distanceMetric(position, center);\n\t\t\tif (distance < minDistance) {\n\t\t\t\tnearestItems = [element];\n\t\t\t\tminDistance = distance;\n\t\t\t} else if (distance === minDistance) {\n\t\t\t\t// Can have multiple items at the same distance in which case we sort by size\n\t\t\t\tnearestItems.push(element);\n\t\t\t}\n\t\t});\n\t\treturn nearestItems;\n\t}\n\tfunction indexMode(chart, e, options) {\n\t\tvar position = helpers.getRelativePosition(e, chart.chart);\n\t\tvar distanceMetric = function(pt1, pt2) {\n\t\t\treturn Math.abs(pt1.x - pt2.x);\n\t\t};\n\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\t\tvar elements = [];\n\t\tif (!items.length) {\n\t\t\treturn [];\n\t\t}\n\t\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\n\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex),\n\t\t\t\t\telement = meta.data[items[0]._index];\n\t\t\t\t// don't count items that are skipped (null data)\n\t\t\t\tif (element && !element._view.skip) {\n\t\t\t\t\telements.push(element);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn elements;\n\t}\n\t/**\n\t * @interface IInteractionOptions\n\t */\n\t/**\n\t * If true, only consider items that intersect the point\n\t * @name IInterfaceOptions#boolean\n\t * @type Boolean\n\t */\n\t/**\n\t * @namespace Chart.Interaction\n\t * Contains interaction related functions\n\t */\n\tChart.Interaction = {\n\t\t// Helper function for different modes\n\t\tmodes: {\n\t\t\tsingle: function(chart, e) {\n\t\t\t\tvar position = helpers.getRelativePosition(e, chart.chart);\n\t\t\t\tvar elements = [];\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\telements.push(element);\n\t\t\t\t\t\treturn elements;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn elements.slice(0, 1);\n\t\t\t},\n\t\t\t/**\n\t\t\t * @function Chart.Interaction.modes.label\n\t\t\t * @deprecated since version 2.4.0\n\t\t\t */\n\t\t\tlabel: indexMode,\n\t\t\t/**\n\t\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t\t * @function Chart.Interaction.modes.index\n\t\t\t * @since v2.4.0\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tindex: indexMode,\n\t\t\t/**\n\t\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t\t * @function Chart.Interaction.modes.dataset\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tdataset: function(chart, e, options) {\n\t\t\t\tvar position = helpers.getRelativePosition(e, chart.chart);\n\t\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false);\n\t\t\t\tif (items.length > 0) {\n\t\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\n\t\t\t\t}\n\t\t\t\treturn items;\n\t\t\t},\n\t\t\t/**\n\t\t\t * @function Chart.Interaction.modes.x-axis\n\t\t\t * @deprecated since version 2.4.0. Use index mode and intersect == true\n\t\t\t */\n\t\t\t'x-axis': function(chart, e) {\n\t\t\t\treturn indexMode(chart, e, true);\n\t\t\t},\n\t\t\t/**\n\t\t\t * Point mode returns all elements that hit test based on the event position\n\t\t\t * of the event\n\t\t\t * @function Chart.Interaction.modes.intersect\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tpoint: function(chart, e) {\n\t\t\t\tvar position = helpers.getRelativePosition(e, chart.chart);\n\t\t\t\treturn getIntersectItems(chart, position);\n\t\t\t},\n\t\t\t/**\n\t\t\t * nearest mode returns the element closest to the point\n\t\t\t * @function Chart.Interaction.modes.intersect\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tnearest: function(chart, e, options) {\n\t\t\t\tvar position = helpers.getRelativePosition(e, chart.chart);\n\t\t\t\tvar nearestItems = getNearestItems(chart, position, options.intersect);\n\t\t\t\t// We have multiple items at the same distance from the event. Now sort by smallest\n\t\t\t\tif (nearestItems.length > 1) {\n\t\t\t\t\tnearestItems.sort(function(a, b) {\n\t\t\t\t\t\tvar sizeA = a.getArea();\n\t\t\t\t\t\tvar sizeB = b.getArea();\n\t\t\t\t\t\tvar ret = sizeA - sizeB;\n\t\t\t\t\t\tif (ret === 0) {\n\t\t\t\t\t\t\t// if equal sort by dataset index\n\t\t\t\t\t\t\tret = a._datasetIndex - b._datasetIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// Return only 1 item\n\t\t\t\treturn nearestItems.slice(0, 1);\n\t\t\t},\n\t\t\t/**\n\t\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t\t * @function Chart.Interaction.modes.x\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tx: function(chart, e) {\n\t\t\t\tvar position = helpers.getRelativePosition(e, chart.chart);\n\t\t\t\tvar items = [];\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inXRange(position.x)) {\n\t\t\t\t\t\titems.push(element);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn items;\n\t\t\t},\n\t\t\t/**\n\t\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t\t * @function Chart.Interaction.modes.y\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\ty: function(chart, e) {\n\t\t\t\tvar position = helpers.getRelativePosition(e, chart.chart);\n\t\t\t\tvar items = [];\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inYRange(position.y)) {\n\t\t\t\t\t\titems.push(element);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn items;\n\t\t\t}\n\t\t}\n\t};\n};\n"]}