{"version":3,"sources":["lib/chartjs/core/core.ticks.js"],"names":["module","exports","Chart","helpers","Ticks","generators","linear","generationOptions","dataRange","ticks","spacing","stepSize","niceRange","niceNum","max","min","maxTicks","niceMin","Math","floor","niceMax","ceil","minMaxDeltaDivisibleByStepSize","numSpaces","almostEquals","round","push","undefined","j","logarithmic","getValueOrDefault","tickVal","pow","log10","exp","significand","minNotZero","lastTick","formatters","values","value","isArray","tickValue","index","delta","length","abs","logDelta","tickString","numDecimal","toFixed","remain","toExponential"],"mappings":"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","file":"core.ticks.js","sourcesContent":["'use strict';\nmodule.exports = function(Chart) {\n\tvar helpers = Chart.helpers;\n\t/**\n\t * Namespace to hold static tick generation functions\n\t * @namespace Chart.Ticks\n\t */\n\tChart.Ticks = {\n\t\t/**\n\t\t * Namespace to hold generators for different types of ticks\n\t\t * @namespace Chart.Ticks.generators\n\t\t */\n\t\tgenerators: {\n\t\t\t/**\n\t\t\t * Interface for the options provided to the numeric tick generator\n\t\t\t * @interface INumericTickGenerationOptions\n\t\t\t */\n\t\t\t/**\n\t\t\t * The maximum number of ticks to display\n\t\t\t * @name INumericTickGenerationOptions#maxTicks\n\t\t\t * @type Number\n\t\t\t */\n\t\t\t/**\n\t\t\t * The distance between each tick.\n\t\t\t * @name INumericTickGenerationOptions#stepSize\n\t\t\t * @type Number\n\t\t\t * @optional\n\t\t\t */\n\t\t\t/**\n\t\t\t * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum\n\t\t\t * @name INumericTickGenerationOptions#min\n\t\t\t * @type Number\n\t\t\t * @optional\n\t\t\t */\n\t\t\t/**\n\t\t\t * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum\n\t\t\t * @name INumericTickGenerationOptions#max\n\t\t\t * @type Number\n\t\t\t * @optional\n\t\t\t */\n\t\t\t/**\n\t\t\t * Generate a set of linear ticks\n\t\t\t * @method Chart.Ticks.generators.linear\n\t\t\t * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n\t\t\t * @param dataRange {IRange} the range of the data\n\t\t\t * @returns {Array<Number>} array of tick values\n\t\t\t */\n\t\t\tlinear: function(generationOptions, dataRange) {\n\t\t\t\tvar ticks = [];\n\t\t\t\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named\n\t\t\t\t// \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n\t\t\t\t// for details.\n\t\t\t\tvar spacing;\n\t\t\t\tif (generationOptions.stepSize && generationOptions.stepSize > 0) {\n\t\t\t\t\tspacing = generationOptions.stepSize;\n\t\t\t\t} else {\n\t\t\t\t\tvar niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n\t\t\t\t\tspacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n\t\t\t\t}\n\t\t\t\tvar niceMin = Math.floor(dataRange.min / spacing) * spacing;\n\t\t\t\tvar niceMax = Math.ceil(dataRange.max / spacing) * spacing;\n\t\t\t\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\n\t\t\t\tif (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\n\t\t\t\t\tvar minMaxDeltaDivisibleByStepSize = ((generationOptions.max - generationOptions.min) % generationOptions.stepSize) === 0;\n\t\t\t\t\tif (minMaxDeltaDivisibleByStepSize) {\n\t\t\t\t\t\tniceMin = generationOptions.min;\n\t\t\t\t\t\tniceMax = generationOptions.max;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar numSpaces = (niceMax - niceMin) / spacing;\n\t\t\t\t// If very close to our rounded value, use it.\n\t\t\t\tif (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\t\t\t\tnumSpaces = Math.round(numSpaces);\n\t\t\t\t} else {\n\t\t\t\t\tnumSpaces = Math.ceil(numSpaces);\n\t\t\t\t}\n\t\t\t\t// Put the values into the ticks array\n\t\t\t\tticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\t\t\t\tfor (var j = 1; j < numSpaces; ++j) {\n\t\t\t\t\tticks.push(niceMin + (j * spacing));\n\t\t\t\t}\n\t\t\t\tticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n\t\t\t\treturn ticks;\n\t\t\t},\n\t\t\t/**\n\t\t\t * Generate a set of logarithmic ticks\n\t\t\t * @method Chart.Ticks.generators.logarithmic\n\t\t\t * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n\t\t\t * @param dataRange {IRange} the range of the data\n\t\t\t * @returns {Array<Number>} array of tick values\n\t\t\t */\n\t\t\tlogarithmic: function(generationOptions, dataRange) {\n\t\t\t\tvar ticks = [];\n\t\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t\t// the graph\n\t\t\t\tvar tickVal = getValueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n\t\t\t\twhile (tickVal < dataRange.max) {\n\t\t\t\t\tticks.push(tickVal);\n\t\t\t\t\tvar exp;\n\t\t\t\t\tvar significand;\n\t\t\t\t\tif (tickVal === 0) {\n\t\t\t\t\t\texp = Math.floor(helpers.log10(dataRange.minNotZero));\n\t\t\t\t\t\tsignificand = Math.round(dataRange.minNotZero / Math.pow(10, exp));\n\t\t\t\t\t} else {\n\t\t\t\t\t\texp = Math.floor(helpers.log10(tickVal));\n\t\t\t\t\t\tsignificand = Math.floor(tickVal / Math.pow(10, exp)) + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (significand === 10) {\n\t\t\t\t\t\tsignificand = 1;\n\t\t\t\t\t\t++exp;\n\t\t\t\t\t}\n\t\t\t\t\ttickVal = significand * Math.pow(10, exp);\n\t\t\t\t}\n\t\t\t\tvar lastTick = getValueOrDefault(generationOptions.max, tickVal);\n\t\t\t\tticks.push(lastTick);\n\t\t\t\treturn ticks;\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Namespace to hold formatters for different types of ticks\n\t\t * @namespace Chart.Ticks.formatters\n\t\t */\n\t\tformatters: {\n\t\t\t/**\n\t\t\t * Formatter for value labels\n\t\t\t * @method Chart.Ticks.formatters.values\n\t\t\t * @param value the value to display\n\t\t\t * @return {String|Array} the label to display\n\t\t\t */\n\t\t\tvalues: function(value) {\n\t\t\t\treturn helpers.isArray(value) ? value : '' + value;\n\t\t\t},\n\t\t\t/**\n\t\t\t * Formatter for linear numeric ticks\n\t\t\t * @method Chart.Ticks.formatters.linear\n\t\t\t * @param tickValue {Number} the value to be formatted\n\t\t\t * @param index {Number} the position of the tickValue parameter in the ticks array\n\t\t\t * @param ticks {Array<Number>} the list of ticks being converted\n\t\t\t * @return {String} string representation of the tickValue parameter\n\t\t\t */\n\t\t\tlinear: function(tickValue, index, ticks) {\n\t\t\t\t// If we have lots of ticks, don't use the ones\n\t\t\t\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n\t\t\t\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\t\t\t\tif (Math.abs(delta) > 1) {\n\t\t\t\t\tif (tickValue !== Math.floor(tickValue)) {\n\t\t\t\t\t\t// not an integer\n\t\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar logDelta = helpers.log10(Math.abs(delta));\n\t\t\t\tvar tickString = '';\n\t\t\t\tif (tickValue !== 0) {\n\t\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\n\t\t\t\t\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\t\t\t\t\ttickString = tickValue.toFixed(numDecimal);\n\t\t\t\t} else {\n\t\t\t\t\ttickString = '0'; // never show decimal places for 0\n\t\t\t\t}\n\t\t\t\treturn tickString;\n\t\t\t},\n\t\t\tlogarithmic: function(tickValue, index, ticks) {\n\t\t\t\tvar remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));\n\t\t\t\tif (tickValue === 0) {\n\t\t\t\t\treturn '0';\n\t\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n\t\t\t\t\treturn tickValue.toExponential();\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t};\n};\n"]}